{
	"Singleton": {
		"prefix": "singleton",
		"body": [
            "//required includes:",
			"// #include <iostream>",
			"// using namespace std;",
			" ",
			"class Singleton {",
			"\tstatic Singleton *instance;",
			"\t${1:int} data;",
			" ",
			"\t// Private constructor so that no objects can be created.",
			"\tSingleton() {",
			"\t\tdata = ${2:0};",
			"\t}",
			" ",
			"public:",
			"\tstatic Singleton *getInstance() {",
			"\t\tif (!instance)",
			"\t\t\tinstance = new Singleton;",
			"\t\treturn instance;",
			"\t}",
			" ",
			"\t${1:int} getData() {",
			"\t\treturn this->data;",
			"\t}",
			" ",
			"\tvoid setData(${1:int} data) {",
			"\t\tthis->data = data;",
			"\t}",
			"};",
			" ",
			"// ====================== SINGLETON DEMO ======================",
			" ",
			"// Singleton *Singleton::instance = 0;",
			" ",
			"//int main() {",
			"\t// Singleton *s = s->getInstance();",
    		"\t// cout << s->getData() << endl;",
    		"\t// s->setData(${3:100});",
    		"\t// cout << s->getData() << endl;",
    		"\t// return 0;",
			"// }"
		],
		"description": "Code snippet for singleton design pattern."
	},
    "Builder": {
        "prefix": "builder",
        "body": [
            "//Required includes:",
            "//#include <iostream>",
            "//#include <vector>",
            " ",
            "class Product{",
            "\tpublic:",
            "\t\tstd::vector<std::string> parts_;",
            "\t\tvoid ListParts()const{",
            "\t\t\tstd::cout << \"Product parts: \";",
            "\t\t\tfor (size_t i=0;i<parts_.size();i++){",
            "\t\t\t\tif(parts_[i]== parts_.back()){",
            "\t\t\t\t\tstd::cout << parts_[i];",
            "\t\t\t\t}else{",
            "\t\t\t\t\tstd::cout << parts_[i] << \", \";",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tstd::cout << \"\n\n\";",
            "\t\t}",
            "\t};",
            " ",
            "\tclass Builder{",
            "\tpublic:",
            "\t\tvirtual ~Builder(){}",
            "\t\tvirtual void ProducePartA() const =0;",
            "\t\tvirtual void ProducePartB() const =0;",
            "\t};",
            " ",
            "\tclass ConcreteBuilder : public Builder{",
            "\tprivate:",
            "\t\tProduct* product;",
            " ",
            "\tpublic:",
            "\t\tConcreteBuilder(){",
            "\t\t\tthis->Reset();",
            "\t\t}",
            " ",
            "\t\t~ConcreteBuilder(){",
            "\t\t\tdelete product;",
            "\t\t}",
            " ",
            "\t\tvoid Reset(){",
            "\t\t\tthis->product= new Product();",
            "\t\t}",
            " ",
            "\t\tvoid ProducePartA()const override{",
            "\t\t\tthis->product->parts_.push_back(\"PartA\");",
            "\t\t}",
            " ",
            "\t\tvoid ProducePartB()const override{",
            "\t\t\tthis->product->parts_.push_back(\"PartB\");",
            "\t\t}",
            " ",
            "\t\tProduct* GetProduct() {",
            "\t\t\tProduct* result= this->product;",
            "\t\t\tthis->Reset();",
            "\t\t\treturn result;",
            "\t\t},",
            "\t};",
            " ",
            "\tclass Director{",
            "\tprivate:",
            "\t\tBuilder* builder;",
            " ",
            "\tpublic:",
            "\t\tvoid set_builder(Builder* builder){",
            "\t\t\tthis->builder=builder;",
            "\t\t}",
            " ",
            "\t\tvoid BuildMinimalViableProduct(){",
            "\t\t\tthis->builder->ProducePartA();",
            "\t\t}",
            " ",
            "\t\tvoid BuildFullFeaturedProduct(){",
            "\t\t\tthis->builder->ProducePartA();",
            "\t\t\tthis->builder->ProducePartB();",
            "\t\t}",
            "\t};",
            " ",
            "// ====================== BUILDER DEMO ======================",
            "/*",
            "\tvoid ClientCode(Director& director)",
            "\t{",
            "\t\tConcreteBuilder* builder = new ConcreteBuilder();",
            "\t\tdirector.set_builder(builder);",
            "\t\tstd::cout << \"Standard basic product:\n\";",
            "\t\tdirector.BuildMinimalViableProduct();",
            " ",
            "\t\tProduct* p= builder->GetProduct();",
            "\t\tp->ListParts();",
            "\t\tdelete p;",
            " ",
            "\t\tstd::cout << \"Standard full featured product:\n\";",
            "\t\tdirector.BuildFullFeaturedProduct();",
            " ",
            "\t\tp= builder->GetProduct();",
            "\t\tp->ListParts();",
            "\t\tdelete p;",
            " ",
            "\t\tstd::cout << \"Custom product:\n\";",
            "\t\tbuilder->ProducePartA();",
            "\t\tp=builder->GetProduct();",
            "\t\tp->ListParts();",
            "\t\tdelete p;",
            " ",
            "\t\tdelete builder;",
            "\t}",
            " ",
            "\tint main(){",
            "\t\tDirector* director= new Director();",
            "\t\tClientCode(*director);",
            "\t\tdelete director;",
            "\t\treturn 0;",
            "\t}",
            "*/"
        ],
        "description": "Code snippet for builder design pattern."
    },
    "Adapter": {
        "prefix": "adapter",
        "body": [
            "//required includes for example code",
            "//#include <iostream>",
            "//#include <algorithm>",
            " ",
            "class Target {",
            "public:",
            "\tvirtual ~Target() = default;",
            " ",
            "\tvirtual std::string Request() const {",
            "\t\treturn \"Target: The default target's behavior.\";",
            "\t}",
            "};",
            " ",
            "//Adaptee class returns reversed text, hard to read",
            "class Adaptee{",
            "public:",
            "\tstd::string SpecificRequest() const {",
            "\t\treturn \".eetpadA eht fo roivaheb laicepS\";",
            "\t}",
            "};",
            " ",
            "//Adapter reverses text to make adaptee class usable",
            "class Adapter : public Target {",
            "private:",
            "\tAdaptee *adaptee_;",
            " ",
            "public:",
            "\tAdapter(Adaptee *adaptee) : adaptee_(adaptee) {}",
            "\tstd::string Request() const override {",
            "\t\tstd::string to_reverse = this->adaptee_->SpecificRequest();",
            "\t\tstd::reverse(to_reverse.begin(), to_reverse.end());",
            "\t\treturn \"Adapter: (TRANSLATED) \" + to_reverse;",
            "\t}",
            "};",
            " ",
            "void ClientCode(const Target *target) {",
            "\tstd::cout << target->Request();",
            "}",
            " ",
            "// ====================== BUILDER DEMO ======================",
            "/*",
            "int main(){",
            "\tAdaptee *adaptee = new Adaptee;",
            "\tstd::cout << \"Client: The Adaptee class reads backwards:\n\";",
            "\tstd::cout << \"Adaptee: \" << adaptee->SpecificRequest();",
            "\tstd::cout << \"\n\nClient: But using the adapter makes it legible:\n\";",
            "\tAdapter *adapter = new Adapter(adaptee);",
            "\tClientCode(adapter);",
            "\tstd::cout << \"\n\";",
            " ",
            "\tdelete adaptee;",
            "\tdelete adapter;",
            " ",
            "\treturn 0;",
            "}",
            "*/"
        ],
        "description": "Code snippet for adapter design pattern."
    },
    "Observer": {
        "prefix": "observer",
        "body": [
            "//required includes",
            "//#include <vector>",
            "//#include <functional>",
            "//observer generic class",
            "class observer{",
            "public:",
            "\tvirtual void notify() = 0;",
            "};",
            "//concrete observer class",
            "class observer_concrete : public observer{",
            "public:",
            "\tvirtual void notify() override{ }",
            "};",
            "class subject{",
            "public:",
            "\t//add observer to list",
            "\tvoid register_observer(observer& o){",
            "\t\tobservers.push_back(o);",
            "\t}",
            "\t//notify of observers in list",
            "\tvoid notify_observers(){",
            "\t\tfor (observer& o : observers){",
            "\t\t\to.notify();",
            "\t\t}",
            "\t}",
            "private:",
            "\t//allows observers to be assignable",
            "\tstd::vector<std::reference_wrapper<observer>> observers;",
            "};"
        ],
        "description": "Code snippet for observer design pattern."
    }
}
